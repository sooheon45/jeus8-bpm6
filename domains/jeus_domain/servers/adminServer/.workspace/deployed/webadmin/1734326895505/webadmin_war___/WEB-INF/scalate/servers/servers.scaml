- import jeus.tool.webadmin.controller.servers.ServerTypeWrapper
- import jeus.tool.webadmin.controller.servers.ServerTemplateTypeWrapper
- import jeus.tool.webadmin.Current
- import jeus.tool.webadmin.Settings
- import jeus.tool.webadmin.Environment

-@ val model_server: List[ServerTypeWrapper] = Nil
-@ val model_template: List[ServerTemplateTypeWrapper] = Nil
-@ val __nodeNames: List[String] = Nil
- val jEnv = S.eval[Environment]("@j_env")

-@ val isRuntime: Boolean = false

- implicit val dialogOption = DialogOption(alwaysRender = false)

- def render(model_server: List[ServerTypeWrapper])
	- if(jEnv.isCloud)
		= Table.sortable(null, model_server, sortBy = {r: ServerTypeWrapper => if(r.adminServer) "0" else r.name})
			- case 0 =>
				- Item("message:header.name")
					- (index, row) =>
						- val name = row.name
						- val uri = J.buildUri("/servers/{name}", name)
						%a(href='#{uri}')
							= name
							- if (row.adminServer)
								(*)
			- case 1 =>
				- Item("message:header.status", "180px")
					- (index, row) =>
						= row.status
			- case 2 =>
				- Item("message:header.pid", "60px", "center")
					- (index, row) =>
						= row.pid
			- case 3 =>
				- Item("message:header.need-to-restart", "110px", "center")
					- (index, row) =>
						= row.needToRestart
	- else
		= Table.sortable(null, model_server, sortBy = {r: ServerTypeWrapper => if(r.adminServer) "0" else r.name})
			- case 0 =>
				- Item.checkallCustom(".tableType", name = "servers", col = "30px")
					- row =>
						- (row.name, row.adminServer, false)
			- case 1 =>
				- Item("message:header.name")
					- (index, row) =>
						- val name = row.name
						- val uri = J.buildUri("/servers/{name}", name)
						%a(href='#{uri}')
							= name
							- if (row.adminServer)
								(*)
			- case 2 =>
				- Item("message:header.status", "180px")
					- (index, row) =>
						= row.status
			- case 3 =>
				- Item("message:header.pid", "60px", "center")
					- (index, row) =>
						= row.pid
			- case 4 =>
				- Item("message:header.need-to-restart", "110px", "center")
					- (index, row) =>
						= row.needToRestart
			- case 5 =>
				- Item("message:header.command", "110px", "center")
					- (index, row) =>
						- val name = row.name
						- val status = row.status match {case null => ""; case s => s}
						- val uri = J.buildUri("/servers/{name}", name)
						- val disabledStart = hasLockAndNoAutoLock || isRuntime
						- J.render("formButton", Map("label" -> "message:common.start.button", "action" -> (uri + "/start"), "cssClass" -> "bt2", "disabled" -> disabledStart, "dialogTemplateUri" -> "servers/startserver", "dialogParams" -> Map("name" -> name, "action" -> {uri + "/start"})))
						- val disabledStop = (hasLockAndNoAutoLock || row.adminServer) || isRuntime
						- J.render("formButton", Map("label" -> "message:common.stop.button", "action" -> (uri + "/stop"), "cssClass" -> "bt2", "disabled" -> disabledStop, "dialogTemplateUri" -> "servers/stopserver", "dialogParams" -> Map("name" -> name, "action" -> {uri + "/stop"})))
			- case 6 =>
				- Item("130px", List("center"),
					- Head
						- () =>
							- J.render("formButton", Map("btype" -> "submit", "label" -> "message:common.remove.button", "method" -> "delete", "cssClass" -> "bt_del", "confirm" -> true, "disabled" -> !hasLock, "appendTarget" -> "input[name=servers]"))
							- J.render("formButton", Map("name" -> "create", "label" -> "message:common.add.button", "cssClass" -> "bt_add", "disabled" -> !hasLock))
	
				- ) 
					- (index, row) =>
						- val name = row.name
						- val uri = J.buildUri("/servers/{name}", name)
						- val disabled = row.status match 
							- case status: String if status.startsWith(S.message("level.RUNNING")) => 
								- !hasLock || row.adminServer || true
							- case _ =>
								- !hasLock
						- val confirmDelete: Boolean = S.eval[Settings]("@settings").referenceDelete						
						- J.render("formButton", Map("btype" -> "submit", "label" -> "message:common.remove.button", "action" -> uri, "method" -> "delete", "cssClass" -> "bt_del", "disabled" -> disabled, "confirm" -> confirmDelete, "message" -> "message:common.confirm.reference.delete.message"))
						- J.render("formButton", Map("btype" -> "submit", "label" -> "message:common.duplicate.button", "action" -> uri, "method" -> "put", "cssClass" -> "bt_add", "disabled" -> {!hasLock || row.autoGenerated}, "dialogTemplateUri" -> "servers/dupserver", "dialogParams" -> Map("name" -> name, "action" -> uri, "nodeNames" -> __nodeNames)))
	- if(!jEnv.isCloud)				
		.buttonGroup
			- J.dialog("formButton", Map("label" -> "message:common.start.button", "cssClass" -> "bt2", "disabled" -> hasLockAndNoAutoLock, "name" -> "start", "appendTarget" -> "input[name=servers]"))
				%article
					%h2.title
						= S.message("common.start.title")
					%form(method="post" action="#{requestUri}")
						.hidden
						%input(type="hidden" name="start" value="start")
						- J.layout("basic")
							.table
								- J.field(label = "message:common.force.label", description = "message:servers.startserver.force.description")
									%input(type="checkbox" name="force")
								- J.field(label = "message:monitoring.servers.common.standby.label", description = "message:servers.startserver.standby.description")
									%input(type="checkbox" name="standby")
								- J.field(label = "message:monitoring.servers.sequential.label", description = "message:servers.startserver.sequential.description")
									%input(type="checkbox" name="seq")
			- J.dialog("formButton", Map("label" -> "message:common.stop.button", "cssClass" -> "bt2", "disabled" -> hasLockAndNoAutoLock, "name" -> "stop", "appendTarget" -> "input[name=servers]"))
				%article
					%h2.title
						= S.message("common.stop.title")
					%form(method="post" action="#{requestUri}")
						.hidden
						%input(type="hidden" name="stop" value="stop")
						- J.layout("basic")
							.table
								- val choiceGroup = "stop-optionGroup_" + J.newID
								- J.field(label = "message:common.timeout.label", description = "message:servers.stopserver.timeout.description", path = "timeout", noBinding = true, attributes = Map("front" -> "choice", "choiceGroup" -> choiceGroup, "choiceDisabled" -> false, "checked" -> false))
									%input(type="text" name="timeout")
								- J.field(label = "message:common.force.label", description = "message:servers.stopserver.force.description", path = "force", noBinding = true, attributes = Map("front" -> "choice", "choiceGroup" -> choiceGroup, "choiceDisabled" -> false, "checked" -> false))
									%input(type="checkbox" name="force" value="true" checked="checked" onclick="return false;")
								- J.field(label = "message:common.graceful.label", description = "message:servers.stopserver.graceful.description", path = "graceful", noBinding = true, attributes = Map("front" -> "choice", "choiceGroup" -> choiceGroup, "choiceDisabled" -> false, "checked" -> false))
									%input(type="checkbox" name="graceful" value="true" checked="checked" onclick="return false;")


- layout("/WEB-INF/scalate/layouts/main.scaml", Map("title" -> "message:common.servers.label"))
	- J.base = "domain.servers"
	- if(!jEnv.isCloud)	
		- J.render("changeServerGroup")
	
	- S.eval[Current]("@current").serverGroupType match
		- case "node" =>
			%h2.title
				= S.message("common.servers.by.node")
			- model_server.groupBy(_.nodeName).toList.sortBy{case (key, _) => if(hasText(key)) key else "0"}.foreach
				- case (null, model_server: List[ServerTypeWrapper]) =>
					- render(model_server)
				- case (key: String, model_server: List[ServerTypeWrapper]) =>
					%h3.title
						= key
					- render(model_server)

		- case "group" =>
			%h2.title
				= S.message("common.servers.by.group")
			- model_server.groupBy(_.group).toList.sortBy{case (key, _) => if(hasText(key)) key else "0"}.foreach
				- case (null, model_server: List[ServerTypeWrapper]) =>
					- render(model_server)
				- case (key: String, model_server: List[ServerTypeWrapper]) =>
					%h3.title
						= key
					- render(model_server)

		- case "cluster" =>
			%h2.title
				= S.message("common.servers.by.cluster")
			- model_server.groupBy(_.cluster).toList.sortBy{case (key, _) => if(hasText(key)) key else "0"}.foreach
				- case (null, model_server: List[ServerTypeWrapper]) =>
					- render(model_server)
				- case (key: String, model_server: List[ServerTypeWrapper]) =>
					%h3.title
						- val uri = J.buildUri("/clusters/{name}", key)
						%a(href="#{uri}")
							= key
					- render(model_server)
		- case _ =>
			%h2.title
				= S.message("common.servers.label")
			- render(model_server)
	
	- if(!jEnv.isCloud)	
		%h2.title
			= S.message("servers.servertemplates.title")
		= Table.sortable(null, model_template, sortBy = {r: ServerTemplateTypeWrapper => r.name})
			- case 1 =>
				- Item("message:header.name")
					- (index, row) =>
						- val url = J.buildUri("/servertemplate/{name}", row.name)
						%a(href="#{url}") = row.name
			- case 2 =>
				- Item("130px", List("center"),
					- Head
						- () =>
							- val url = J.buildUri("/servertemplate")
							- J.render("formButton", Map("name" -> "create", "label" -> "message:common.add.button", "disabled" -> !hasLock, "cssClass" -> "bt_add", "action" -> url))
				- )
					- (index, row) =>
						- val url = J.buildUri("/servertemplate/{name}", row.name)
						- J.render("formButton", Map("label" -> "message:common.remove.button", "cssClass" -> "bt_del", "method" -> "delete", "disabled" -> !hasLock, "action" -> url, "confirm" -> true, "message" -> "message:common.confirm.reference.delete.message"))
						
						